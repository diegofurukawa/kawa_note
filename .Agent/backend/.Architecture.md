# ARCHITECTURE — BACKEND

## Visão Geral
Backend monolítico em Node.js/Fastify com arquitetura em camadas (MVC).

**Objetivo:** Fornecer API REST segura, performática e escalável para gerenciamento de notas, pastas e relações.

---

## Arquitetura em Camadas

```
┌─────────────────────────────────────────┐
│         HTTP Requests (Fastify)         │
├─────────────────────────────────────────┤
│         Middleware Layer                │
│  ├─ auth.middleware.js (JWT)            │
│  └─ error.middleware.js (Tratamento)    │
├─────────────────────────────────────────┤
│         Controller Layer                │
│  ├─ auth.controller.js                  │
│  ├─ notes.controller.js                 │
│  ├─ folders.controller.js               │
│  ├─ relations.controller.js             │
│  └─ apps.controller.js                  │
├─────────────────────────────────────────┤
│         Service Layer                   │
│  ├─ auth.service.js (Lógica)            │
│  ├─ notes.service.js                    │
│  ├─ folders.service.js                  │
│  ├─ relations.service.js                │
│  └─ apps.service.js                     │
├─────────────────────────────────────────┤
│         Data Layer (Prisma ORM)         │
│  └─ PostgreSQL 16                       │
└─────────────────────────────────────────┘
```

---

## Fluxo de Requisição

1. **HTTP Request** → Fastify recebe
2. **Middleware** → Autenticação (JWT), validação
3. **Router** → Direciona para controller
4. **Controller** → Valida entrada (Zod), chama service
5. **Service** → Lógica de negócio, chama Prisma
6. **Prisma** → Query PostgreSQL
7. **Response** → Retorna JSON formatado

---

## Módulos Principais

### 1. Auth (`backend/src/modules/auth/`)
**Responsabilidade:** Autenticação e autorização

- `auth.controller.js` — Endpoints: register, login, me, logout, refresh
- `auth.service.js` — Lógica: hash senha, gerar JWT, validar token
- `auth.schema.js` — Validação: email, senha, token
- `auth.routes.js` — Rotas: POST /auth/register, POST /auth/login, etc.

**Fluxo:**
```
POST /auth/register
  → Validar email/senha (Zod)
  → Hash senha (bcrypt)
  → Criar usuário (Prisma)
  → Gerar JWT
  → Retornar token
```

### 2. Notes (`backend/src/modules/notes/`)
**Responsabilidade:** CRUD de notas

- `notes.controller.js` — Endpoints: create, read, update, delete, search
- `notes.service.js` — Lógica: validar propriedade, buscar, filtrar
- `notes.schema.js` — Validação: título, conteúdo, tags
- `notes.routes.js` — Rotas: GET/POST/PUT/DELETE /notes

**Fluxo:**
```
POST /notes
  → Autenticar (middleware)
  → Validar dados (Zod)
  → Criar nota (Prisma)
  → Retornar nota criada
```

### 3. Folders (`backend/src/modules/folders/`)
**Responsabilidade:** Hierarquia de pastas

- `folders.controller.js` — Endpoints: create, read, update, delete, tree
- `folders.service.js` — Lógica: validar hierarquia, mover pasta
- `folders.schema.js` — Validação: nome, parent
- `folders.routes.js` — Rotas: GET/POST/PUT/DELETE /folders

### 4. Relations (`backend/src/modules/relations/`)
**Responsabilidade:** Relações entre notas (grafo)

- `relations.controller.js` — Endpoints: create, read, delete, graph
- `relations.service.js` — Lógica: validar relação, detectar ciclos
- `relations.schema.js` — Validação: source, target, type
- `relations.routes.js` — Rotas: GET/POST/DELETE /relations

### 5. Apps (`backend/src/modules/apps/`)
**Responsabilidade:** Configurações públicas

- `apps.controller.js` — Endpoints: getPublicSettings
- `apps.service.js` — Lógica: cache de settings
- `apps.routes.js` — Rotas: GET /apps/public

---

## Middleware

### `auth.middleware.js`
- Verifica JWT em `Authorization: Bearer <token>`
- Injeta `request.user` com dados do usuário
- Retorna 401 se token inválido

### `error.middleware.js`
- Captura erros não tratados
- Formata resposta de erro
- Loga erro com contexto
- Retorna status HTTP apropriado

---

## Banco de Dados (Prisma)

### Schema Principal
```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  notes     Note[]
  folders   Folder[]
  createdAt DateTime @default(now())
}

model Note {
  id        String   @id @default(cuid())
  title     String
  content   String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  folderId  String?
  folder    Folder?  @relation(fields: [folderId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Folder {
  id        String   @id @default(cuid())
  name      String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  parentId  String?
  parent    Folder?  @relation("FolderHierarchy", fields: [parentId], references: [id])
  children  Folder[] @relation("FolderHierarchy")
  notes     Note[]
  createdAt DateTime @default(now())
}

model Relation {
  id        String   @id @default(cuid())
  sourceId  String
  targetId  String
  type      String   // "references", "related", "depends_on"
  createdAt DateTime @default(now())
}
```

### Migrations
- Versionadas em `backend/prisma/migrations/`
- Nunca modificadas após execução
- Criadas via `npx prisma migrate dev --name <name>`

---

## Segurança

### Autenticação
- JWT com `JWT_SECRET` em variável de ambiente
- Tokens com expiração (padrão: 24h)
- Refresh token para renovação

### Autorização
- Verificar `request.user.id` antes de retornar dados
- Usuário só pode acessar seus próprios recursos

### Validação
- Zod em todos os controllers
- Rejeitar entrada inválida com 400
- Mensagens de erro não expõem detalhes internos

### Senhas
- Hash com bcrypt (salt rounds: 10)
- Nunca armazenar em plain text
- Nunca retornar em resposta

---

## Performance

### Queries Otimizadas
- Usar `.select()` para retornar apenas campos necessários
- Usar `.include()` para relações necessárias
- Evitar N+1 queries

### Paginação
- Implementar em endpoints que retornam listas
- Padrão: `?page=1&limit=20`

### Índices
- Adicionar em `schema.prisma` para campos de busca
- Exemplo: `@@index([userId])` em Note

### Caching
- Considerar Redis para dados frequentemente consultados
- Cache de settings públicas

---

## Logging

### Estrutura
```javascript
logger.info({ userId: 123, action: 'create_note' }, 'Note created');
logger.error({ error, userId: 123 }, 'Failed to create note');
```

### Níveis
- `debug` — Informações detalhadas (desenvolvimento)
- `info` — Eventos importantes
- `warn` — Avisos
- `error` — Erros

---

## Tratamento de Erros

### Padrão
```javascript
try {
  const note = await noteService.create(data);
  return reply.code(201).send(note);
} catch (error) {
  logger.error({ error }, 'Failed to create note');
  throw error; // Middleware captura
}
```

### Status HTTP
- `200` — Sucesso
- `201` — Criado
- `400` — Entrada inválida
- `401` — Não autenticado
- `403` — Não autorizado
- `404` — Não encontrado
- `500` — Erro interno

---

## Escalabilidade Futura

### Possíveis Melhorias
1. **Microserviços:** Separar auth, notes, folders em serviços independentes
2. **Message Queue:** Usar RabbitMQ/Kafka para operações assíncronas
3. **Cache:** Redis para cache de queries frequentes
4. **Search:** Elasticsearch para busca full-text
5. **Replicação:** PostgreSQL replication para alta disponibilidade

---

## Checklist de Conformidade
- [ ] Arquitetura em camadas mantida
- [ ] Middleware centralizado
- [ ] Validação Zod em todos os controllers
- [ ] Segurança verificada
- [ ] Performance otimizada
- [ ] Logging estruturado
- [ ] Tratamento de erro centralizado
- [ ] Testes cobrindo fluxos críticos
